<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <title>Les classes internes ou la tambouille du compilateur Java</title>
    <meta name="description" content="" />

    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="shortcut icon" href="https://jcsirot.github.io/hubpress.io/favicon.ico">

    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:400,700,400italic,700italic|Open+Sans:400italic,700italic,700,400">
    <link rel="stylesheet" type="text/css" href="//jcsirot.github.io/hubpress.io/themes/roon/assets/css/screen.css?v=1468688452987" />

    <link rel="canonical" href="https://jcsirot.github.io/hubpress.io/2011/12/26/Les-classes-internes-ou-la-tambouille-du-compilateur-Java.html" />
    <meta name="referrer" content="origin" />
    
    <meta property="og:site_name" content="Coding Stories" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Les classes internes ou la tambouille du compilateur Java" />
    <meta property="og:description" content="Il y a quelques mois Olivier Croisier a publié sur son blog The Coder’s Breakfast (que tout développeur Java se doit de suivre) un article intitulé Inner classes and the myth of the default constructor. Dans cet article il est question des classes internes et des constructeurs « cachés » ajoutés" />
    <meta property="og:url" content="https://jcsirot.github.io/hubpress.io/2011/12/26/Les-classes-internes-ou-la-tambouille-du-compilateur-Java.html" />
    <meta property="article:tag" content="bytecode" />
    <meta property="article:tag" content=" compiler" />
    <meta property="article:tag" content=" java" />
    
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:title" content="Les classes internes ou la tambouille du compilateur Java" />
    <meta name="twitter:description" content="Il y a quelques mois Olivier Croisier a publié sur son blog The Coder’s Breakfast (que tout développeur Java se doit de suivre) un article intitulé Inner classes and the myth of the default constructor. Dans cet article il est question des classes internes et des constructeurs « cachés » ajoutés" />
    <meta name="twitter:url" content="https://jcsirot.github.io/hubpress.io/2011/12/26/Les-classes-internes-ou-la-tambouille-du-compilateur-Java.html" />
    
    <script type="application/ld+json">
null
    </script>

    <meta name="generator" content="HubPress" />
    <link rel="alternate" type="application/rss+xml" title="Coding Stories" href="https://jcsirot.github.io/hubpress.io/rss/" />
</head>
<body class="post-template tag-bytecode tag-compiler tag-java  noimage">

    


    <article role="main" class="">
        <header>
            <a href="https://jcsirot.github.io/hubpress.io" id="home_link">«</a>
            <div class="meta"><time datetime="2011-12-26"><a href="https://jcsirot.github.io/hubpress.io/2011/12/26/Les-classes-internes-ou-la-tambouille-du-compilateur-Java.html">December 26, 2011</a></time> <span class="count" id="js-reading-time"></span></div>
            <h1>Les classes internes ou la tambouille du compilateur Java</h1>
        </header>

        <div class="text" id="js-post-content">
            <div class="paragraph">
<p>Il y a quelques mois Olivier Croisier a publié sur son blog <a href="http://thecodersbreakfast.net/">The Coder’s Breakfast</a> (que tout développeur Java se doit de suivre) un article intitulé <a href="http://thecodersbreakfast.net/index.php?post/2011/09/26/Inner-classes-and-the-myth-of-the-default-constructor">Inner classes and the myth of the default constructor</a>. Dans cet article il est question des classes internes et des constructeurs « cachés » ajoutés lors de la phase de compilation.</p>
</div>
<div class="paragraph">
<p>Prenons ce morceau de code :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Outer
{
    public Outer() {
        new Inner();
    }
    public class Inner {}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Et regardons le bytecode des constructeurs généré par le compilateur :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>// Outer.class
**** &lt;init&gt; () -&gt; void
    0: aload $0
    1: invokespecial java/lang/Object.&lt;init&gt; {() -&gt; void}
    4: new Outer$Inner
    7: dup
    8: aload $0
    9: invokespecial Outer$Inner.&lt;init&gt; {(Outer) -&gt; void}
   12: pop
   13: return

// Outer$Inner.class
**** &lt;init&gt; (Outer) -&gt; void
    0: aload $0
    1: aload $1
    2: putfield Outer$Inner.this$0 {Outer}
    5: aload $0
    6: invokespecial java/lang/Object.&lt;init&gt; {() -&gt; void}
    9: return</pre>
</div>
</div>
<div class="paragraph">
<p>La class <code>Inner</code> s’est vue ajouter un constructeur qui prend un paramètre de type <code>Outer</code> et quand <code>Outer</code> appelle ce constructeur il passe this en paramètre (l’instruction <code>aload $0</code> charge <code>this</code> sur la pile juste avant l’appel du constructeur).</p>
</div>
<div class="paragraph">
<p>En fait la classe interne est vue comme n’importe quelle autre classe. Pour lui permettre d’accès à la classe englobante il lui faut un pointeur vers l’instance de cette classe. Ce pointeur lui est passé en paramètre dans un constructeur ajouté à la compilation.</p>
</div>
<div class="paragraph">
<p>Allons un peu plus loin. Si la classe interne n’est pas différente des autres classes alors que ce passe-t-il quand la classe englobante veut accéder à une méthode <code>private</code> de la classe interne ?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Outer
{
    public Outer() {
        Inner inner = new Inner();
        inner.hello();
    }
    public class Inner {
        private void hello() {
            System.out.println("Hello World");
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Et le bytecode :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>// Outer.class
**** &lt;init&gt; () -&gt; void
    0: aload $0
    1: invokespecial java/lang/Object.&lt;init&gt; {() -&gt; void}
    4: new Outer$Inner
    7: dup
    8: aload $0
    9: invokespecial Outer$Inner.&lt;init&gt; {(Outer) -&gt; void}
   12: astore $1
   13: aload $1
   14: invokestatic Outer$Inner.access$000 {(Outer$Inner) -&gt; void}
   17: return

// Outer$Inner.class
**** &lt;init&gt; (Outer) -&gt; void
    0: aload $0
    1: aload $1
    2: putfield Outer$Inner.this$0 {Outer}
    5: aload $0
    6: invokespecial java/lang/Object.&lt;init&gt; {() -&gt; void}
    9: return

**** hello () -&gt; void
    0: getstatic java/lang/System.out {java.io.PrintStream}
    3: ldc "Hello World"
    5: invokevirtual java/io/PrintStream.println {(java.lang.String) -&gt; void}
    8: return

**** access$000 (Outer$Inner) -&gt; void
    0: aload $0
    1: invokespecial Outer$Inner.hello {() -&gt; void}
    4: return</code></pre>
</div>
</div>
<div class="paragraph">
<p>La méthode <code>hello</code> est privée et donc Outer ne peut pas l&#8217;appeler directement. Dans ce le compilateur a ajouté une méthode package statique void <code>access$000(Inner)</code> qui sert alors de proxy. Cette méthode se contente alors de rediriger l&#8217;appel vers le méthode <code>hello</code>. Dans le code de l&#8217;appelant l&#8217;appel à la méthode privée est simplement remplacé par un appel à la méthode statique correspondante.</p>
</div>
<div class="paragraph">
<p>Dans le cas de l&#8217;accès à un champ privé, le résultat est très similaire :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Outer
{
    public Outer() {
        Inner inner = new Inner();
        String hello = inner.hello;
    }
    public class Inner {
        private String hello = "Hello World";
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>// Outer.class
**** &lt;init&gt; () -&gt; void
    0: aload $0
    1: invokespecial java/lang/Object.&lt;init&gt; {() -&gt; void}
    4: new Outer$Inner
    7: dup
    8: aload $0
    9: invokespecial Outer$Inner.&lt;init&gt; {(Outer) -&gt; void}
   12: astore $1
   13: aload $1
   14: invokestatic Outer$Inner.access$000 {(Outer$Inner) -&gt; java.lang.String}
   17: astore $2
   18: return

// Outer$Inner.class
**** &lt;init&gt; (Outer) -&gt; void
    0: aload $0
    1: aload $1
    2: putfield Outer$Inner.this$0 {Outer}
    5: aload $0
    6: invokespecial java/lang/Object.&lt;init&gt; {() -&gt; void}
    9: aload $0
   10: ldc "Hello World"
   12: putfield Outer$Inner.hello {java.lang.String}
   15: return

**** access$000 (Outer$Inner) -&gt; java.lang.String
    0: aload $0
    1: getfield Outer$Inner.hello {java.lang.String}
    4: areturn</code></pre>
</div>
</div>
<div class="paragraph">
<p>Dans ce cas aussi, l&#8217;accès au champ privé <code>hello</code> n&#8217;est pas possible directement. Le compiltateur a donc ajouté une méthode package statique <code>String access$000(Inner)</code> qui lit le champ (opcode <code>getfield</code>) et le renvoie à l&#8217;appelant.</p>
</div>
<div class="paragraph">
<p>Et dans le cas d&#8217;un constructeur privé ? Vat-t-on se retrouver avec une méthode statique de type <em>factory</em> qui va instancier l&#8217;object qu&#8217;on cherche à construire ? Non, ici le compilateur opte pour une autre stratégie :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Outer
{
    public Outer() {
        Inner inner = new Inner();
    }
    public class Inner {
        private Inner() {}
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>// Outer.class
**** &lt;init&gt; () -&gt; void
    0: aload $0
    1: invokespecial java/lang/Object.&lt;init&gt; {() -&gt; void}
    4: new Outer$Inner
    7: dup
    8: aload $0
    9: aconst_null
   10: invokespecial Outer$Inner.&lt;init&gt; {(Outer, Outer$1) -&gt; void}
   13: astore $1
   14: return

// Outer$Inner.class
**** &lt;init&gt; (Outer) -&gt; void
    0: aload $0
    1: aload $1
    2: putfield Outer$Inner.this$0 {Outer}
    5: aload $0
    6: invokespecial java/lang/Object.&lt;init&gt; {() -&gt; void}
    9: return

**** &lt;init&gt; (Outer, Outer$1) -&gt; void
    0: aload $0
    1: aload $1
    2: invokespecial Outer$Inner.&lt;init&gt; {(Outer) -&gt; void}
    5: return</code></pre>
</div>
</div>
<div class="paragraph">
<p>Le compilateur ajoute un second constructeur qui prend deux paramètres : le pointeur vers l&#8217;instance de la classe englobante et un paramètre de type <code>Outer$1</code>. Quelle est ce type ? Il s&#8217;agit d&#8217;une interface sans méthode créée automatiquement à la compilation. Cette interface sert simplement différencier les deux constructeurs (le second constructeur se contente d&#8217;appeler le premier). Lors de l&#8217;appel de ce constructeur ce second paramètre est mis à null (<code>null</code> est chargé sur la pile par l&#8217;opcode <code>aconst_null</code>).</p>
</div>
<div class="paragraph">
<p>Le problème principal de ces différentes <em>ruses</em> du compilateur est que cela peut rendre les stacktraces difficilement lisibles si on fait un usage immodéré des classes internes. Il vaut mieux également éviter d&#8217;appeler des méthodes privées depuis la classe englobante. L&#8217;analyseur de code <a href="http://pmd.sourceforge.net/">PMD</a> définit d&#8217;ailleurs une règle <a href="http://pmd.sourceforge.net/rules/design.html">AccessorClassGeneration</a> qui lève une alerte quand un constructeur privé est appelé depuis la classe englobante.</p>
</div>
<div class="paragraph">
<p>Et que se passe-t-il si on tente d&#8217;accéder à une méthode privée de la classe englobante depuis la classe interne ? Je vous laisse expérimenter :D.</p>
</div>
        </div>

        <menu>
            <a href="" id="btn_share" class="btn" title="Share">
                <span aria-hidden="true" data-icon="S"></span>
                <strong>Share</strong>
            </a>
            <a href="http://twitter.com/share?text=Les%20classes%20internes%20ou%20la%20tambouille%20du%20compilateur%20Java&url=https://jcsirot.github.io/hubpress.io/2011/12/26/Les-classes-internes-ou-la-tambouille-du-compilateur-Java.html" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;" id="btn_comment" class="btn" target="_blank">
                <span aria-hidden="true" data-icon="C"></span> Comment on Twitter
            </a>
        </menu>


        <footer class="post-footer" role="contentinfo">

            <div class="vcard">
                <a href="https://jcsirot.github.io/hubpress.io/rss" id="btn_feed" class="btn" title="Feed" target="_blank">
                    <span aria-hidden="true" data-icon=")"></span>
                    <strong>Feed</strong>
                </a>

                <a href="https://jcsirot.github.io/hubpress.io/author/jcsirot/" class="photo">
                    <span style="background-image: url('https://avatars.githubusercontent.com/u/470082?v&#x3D;3');">
                        <img src="https://avatars.githubusercontent.com/u/470082?v&#x3D;3" alt="Jean-Christophe Sirot">
                    </span>
                </a>

                <div class="details">
                    <h4><a href="https://jcsirot.github.io/hubpress.io/author/jcsirot/" class="url n">Jean-Christophe Sirot</a></h4>
                    Paris<br>
                    <a href="http://www.coding-stories.com/" class="js-remove-domain-schema">http://www.coding-stories.com/</a>
                </div>
            </div>

            <div id="user_bio">
                <div class="inner">
                    
                </div>
            </div>

        </footer>




    </article>

    <div id="share_modal">
        <div class="wrap">
            <div class="inner">
                <header>
                    Share
                    <a href="" class="close" title="Close">&times;</a>
                </header>

                <div class="roon-share-links">
                    <a href="https://twitter.com/share" class="twitter-share-button" data-dnt="true">Tweet</a>
                    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>

                    <div id="fb-elems">
                        <div id="fb-root"></div>
                        <script>(function(d, s, id) {
                        var js, fjs = d.getElementsByTagName(s)[0];
                        if (d.getElementById(id)) return;
                        js = d.createElement(s); js.id = id;
                        js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=463438580397968";
                        fjs.parentNode.insertBefore(js, fjs);
                        }(document, 'script', 'facebook-jssdk'));</script>
                        <div class="fb-like" data-send="false" data-layout="button_count" data-width="110" data-show-faces="false" data-font="arial"></div>
                    </div>

                    <div id="pinit-btn">
                        <a href="//pinterest.com/pin/create/button/?url=https://jcsirot.github.io/hubpress.io/2011/12/26/Les-classes-internes-ou-la-tambouille-du-compilateur-Java.html&amp;description=Les%20classes%20internes%20ou%20la%20tambouille%20du%20compilateur%20Java-Coding%20Stories " data-pin-do="buttonPin" data-pin-config="beside"><img src="//assets.pinterest.com/images/pidgets/pin_it_button.png"></a>
                        <script type="text/javascript" src="//assets.pinterest.com/js/pinit.js"></script>
                    </div>
                </div>
            </div>
        </div>
    </div>






    <script>

            function get_text(el) {
                ret = "";
                var length = el.childNodes.length;
                for(var i = 0; i < length; i++) {
                    var node = el.childNodes[i];
                    if(node.nodeType != 8) {
                        ret += node.nodeType != 1 ? node.nodeValue : get_text(node);
                    }
                }
                return ret;
            }
            function reading_time () {
                var post_content = document.getElementById('js-post-content');
                if (post_content) {
                    var words = get_text(post_content),
                        count = words.split(/\s+/).length,
                        read_time = Math.ceil((count / 150)),
                        read_time_node = document.createTextNode(read_time + ' min read');
                    document.getElementById('js-reading-time').appendChild(read_time_node);
                }
            }

        function no_schema_links () {
            var links = document.querySelectorAll('.js-remove-domain-schema');
            if (links) {
                for (i = 0; i < links.length; ++i) {
                    var link = links[i],
                        text = link.innerHTML,
                        no_schema = text.replace(/.*?:\/\//g, "");
                    link.innerHTML = no_schema;
                }
            }
        }

        window.onload = function () {
            no_schema_links();

            reading_time();
        }
    </script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js?v="></script> <script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.9.0/moment-with-locales.min.js?v="></script> <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js?v="></script> 
      <script type="text/javascript">
        jQuery( document ).ready(function() {
          // change date with ago
          jQuery('ago.ago').each(function(){
            var element = jQuery(this).parent();
            element.html( moment(element.text()).fromNow());
          });
        });

        hljs.initHighlightingOnLoad();
      </script>

        <script>
            $(function(){
                var share_modal = $("#share_modal"),
                    update_social_links = true;

                $("#btn_share").click(function(){
                    var that = $(this);
                    share_modal.fadeIn(200);
                    return false;
                });

                share_modal.click(function(e){
                    if (e.target.className == "wrap" || e.target.id == "share_modal") {
                        share_modal.fadeOut(200);
                    }
                    return false;
                });

                share_modal.find("div.inner > header > a.close").click(function(){
                    share_modal.fadeOut(200);
                    return false;
                });
            });
        </script>



</body>
</html>
