<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>Les classes internes ou la tambouille du compilateur Java</title>
    <meta name="description" content="" />
    <link href="//fonts.googleapis.com/css?family=Noto+Sans:300,400,700" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Noto+Serif:400,700,400italic" rel="stylesheet" type="text/css">
    <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
    <link href="//jcsirot.github.io/hubpress.io/themes/saga/assets/css/style.css?v=1468853091917" rel="stylesheet" type="text/css">
    <link href="//jcsirot.github.io/hubpress.io/themes/saga/assets/css/animate.min.css?v=1468853091917" rel="stylesheet" type="text/css">
    <link href="https://jcsirot.github.io/hubpress.io/favicon.ico" rel="shortcut icon">
    <link rel="canonical" href="https://jcsirot.github.io/hubpress.io/2011/12/26/Les-classes-internes-ou-la-tambouille-du-compilateur-Java.html" />
    <meta name="referrer" content="origin" />
    
    <meta property="og:site_name" content="Coding Stories" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Les classes internes ou la tambouille du compilateur Java" />
    <meta property="og:description" content="Il y a quelques mois Olivier Croisier a publié sur son blog The Coder’s Breakfast (que tout développeur Java se doit de suivre) un article intitulé Inner classes and the myth of the default constructor. Dans cet article il est question des classes internes et des constructeurs « cachés » ajoutés" />
    <meta property="og:url" content="https://jcsirot.github.io/hubpress.io/2011/12/26/Les-classes-internes-ou-la-tambouille-du-compilateur-Java.html" />
    <meta property="article:tag" content="bytecode" />
    <meta property="article:tag" content=" compiler" />
    <meta property="article:tag" content=" java" />
    
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:title" content="Les classes internes ou la tambouille du compilateur Java" />
    <meta name="twitter:description" content="Il y a quelques mois Olivier Croisier a publié sur son blog The Coder’s Breakfast (que tout développeur Java se doit de suivre) un article intitulé Inner classes and the myth of the default constructor. Dans cet article il est question des classes internes et des constructeurs « cachés » ajoutés" />
    <meta name="twitter:url" content="https://jcsirot.github.io/hubpress.io/2011/12/26/Les-classes-internes-ou-la-tambouille-du-compilateur-Java.html" />
    
    <script type="application/ld+json">
null
    </script>

    <meta name="generator" content="HubPress" />
    <link rel="alternate" type="application/rss+xml" title="Coding Stories" href="https://jcsirot.github.io/hubpress.io/rss/" />
</head>
<body class="post-template tag-bytecode tag-compiler tag-java">
    <header id="header" class="animated fadeIn">
    <div class="header-background">
    <section class="blog-content">
        <a id="site-url" class="blog-title" href="https://jcsirot.github.io/hubpress.io">Coding Stories</a>
        <span class="blog-description">Singe savant en ingénierie logicielle</span>
        <nav class="links fadeIn animated">
            <ul>
                <li class="rss"><a title="RSS Feed" href="/rss/"><i class="fa fa-fw fa-rss-square"></i></a></li>
        
            </ul>
        </nav>
    </section>
    <section class="header-content">
        <h1 class="post-title animated fadeInUp">Les classes internes ou la tambouille du compilateur Java</h1>
        <span class="post-data"><span class="date animated fadeInUp"><i class="fa fa-clock-o"></i> <time class="timesince date" data-timesince="1324854000" datetime="2011-12-26T00:00" title="26 December 2011">5 years ago</time></span>
            <span class="tags animated fadeInUp"><i class="fa fa-tags"></i> <a href="https://jcsirot.github.io/hubpress.io/tag/bytecode/">bytecode</a>, <a href="https://jcsirot.github.io/hubpress.io/tag/compiler/"> compiler</a>, <a href="https://jcsirot.github.io/hubpress.io/tag/java/"> java</a></span>
            <span class="author animated fadeInUp"><i class="fa fa-user"></i> <a href="https://jcsirot.github.io/hubpress.io/author/jcsirot/">Jean-Christophe Sirot</a></span></span>
    </section>
    </div>
</header>
<main id="main" class="content">
    <article itemtype="http://schema.org/BlogPosting" class="animated fadeIn content post post tag-bytecode tag-compiler tag-java">
        <section class="post-content">
            <div class="paragraph">
<p>Il y a quelques mois Olivier Croisier a publié sur son blog <a href="http://thecodersbreakfast.net/">The Coder’s Breakfast</a> (que tout développeur Java se doit de suivre) un article intitulé <a href="http://thecodersbreakfast.net/index.php?post/2011/09/26/Inner-classes-and-the-myth-of-the-default-constructor">Inner classes and the myth of the default constructor</a>. Dans cet article il est question des classes internes et des constructeurs « cachés » ajoutés lors de la phase de compilation.</p>
</div>
<div class="paragraph">
<p>Prenons ce morceau de code :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Outer
{
    public Outer() {
        new Inner();
    }
    public class Inner {}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Et regardons le bytecode des constructeurs généré par le compilateur :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>// Outer.class
**** &lt;init&gt; () -&gt; void
    0: aload $0
    1: invokespecial java/lang/Object.&lt;init&gt; {() -&gt; void}
    4: new Outer$Inner
    7: dup
    8: aload $0
    9: invokespecial Outer$Inner.&lt;init&gt; {(Outer) -&gt; void}
   12: pop
   13: return

// Outer$Inner.class
**** &lt;init&gt; (Outer) -&gt; void
    0: aload $0
    1: aload $1
    2: putfield Outer$Inner.this$0 {Outer}
    5: aload $0
    6: invokespecial java/lang/Object.&lt;init&gt; {() -&gt; void}
    9: return</pre>
</div>
</div>
<div class="paragraph">
<p>La class <code>Inner</code> s’est vue ajouter un constructeur qui prend un paramètre de type <code>Outer</code> et quand <code>Outer</code> appelle ce constructeur il passe this en paramètre (l’instruction <code>aload $0</code> charge <code>this</code> sur la pile juste avant l’appel du constructeur).</p>
</div>
<div class="paragraph">
<p>En fait la classe interne est vue comme n’importe quelle autre classe. Pour lui permettre d’accès à la classe englobante il lui faut un pointeur vers l’instance de cette classe. Ce pointeur lui est passé en paramètre dans un constructeur ajouté à la compilation.</p>
</div>
<div class="paragraph">
<p>Allons un peu plus loin. Si la classe interne n’est pas différente des autres classes alors que ce passe-t-il quand la classe englobante veut accéder à une méthode <code>private</code> de la classe interne ?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Outer
{
    public Outer() {
        Inner inner = new Inner();
        inner.hello();
    }
    public class Inner {
        private void hello() {
            System.out.println("Hello World");
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Et le bytecode :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>// Outer.class
**** &lt;init&gt; () -&gt; void
    0: aload $0
    1: invokespecial java/lang/Object.&lt;init&gt; {() -&gt; void}
    4: new Outer$Inner
    7: dup
    8: aload $0
    9: invokespecial Outer$Inner.&lt;init&gt; {(Outer) -&gt; void}
   12: astore $1
   13: aload $1
   14: invokestatic Outer$Inner.access$000 {(Outer$Inner) -&gt; void}
   17: return

// Outer$Inner.class
**** &lt;init&gt; (Outer) -&gt; void
    0: aload $0
    1: aload $1
    2: putfield Outer$Inner.this$0 {Outer}
    5: aload $0
    6: invokespecial java/lang/Object.&lt;init&gt; {() -&gt; void}
    9: return

**** hello () -&gt; void
    0: getstatic java/lang/System.out {java.io.PrintStream}
    3: ldc "Hello World"
    5: invokevirtual java/io/PrintStream.println {(java.lang.String) -&gt; void}
    8: return

**** access$000 (Outer$Inner) -&gt; void
    0: aload $0
    1: invokespecial Outer$Inner.hello {() -&gt; void}
    4: return</code></pre>
</div>
</div>
<div class="paragraph">
<p>La méthode <code>hello</code> est privée et donc Outer ne peut pas l&#8217;appeler directement. Dans ce le compilateur a ajouté une méthode package statique void <code>access$000(Inner)</code> qui sert alors de proxy. Cette méthode se contente alors de rediriger l&#8217;appel vers le méthode <code>hello</code>. Dans le code de l&#8217;appelant l&#8217;appel à la méthode privée est simplement remplacé par un appel à la méthode statique correspondante.</p>
</div>
<div class="paragraph">
<p>Dans le cas de l&#8217;accès à un champ privé, le résultat est très similaire :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Outer
{
    public Outer() {
        Inner inner = new Inner();
        String hello = inner.hello;
    }
    public class Inner {
        private String hello = "Hello World";
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>// Outer.class
**** &lt;init&gt; () -&gt; void
    0: aload $0
    1: invokespecial java/lang/Object.&lt;init&gt; {() -&gt; void}
    4: new Outer$Inner
    7: dup
    8: aload $0
    9: invokespecial Outer$Inner.&lt;init&gt; {(Outer) -&gt; void}
   12: astore $1
   13: aload $1
   14: invokestatic Outer$Inner.access$000 {(Outer$Inner) -&gt; java.lang.String}
   17: astore $2
   18: return

// Outer$Inner.class
**** &lt;init&gt; (Outer) -&gt; void
    0: aload $0
    1: aload $1
    2: putfield Outer$Inner.this$0 {Outer}
    5: aload $0
    6: invokespecial java/lang/Object.&lt;init&gt; {() -&gt; void}
    9: aload $0
   10: ldc "Hello World"
   12: putfield Outer$Inner.hello {java.lang.String}
   15: return

**** access$000 (Outer$Inner) -&gt; java.lang.String
    0: aload $0
    1: getfield Outer$Inner.hello {java.lang.String}
    4: areturn</code></pre>
</div>
</div>
<div class="paragraph">
<p>Dans ce cas aussi, l&#8217;accès au champ privé <code>hello</code> n&#8217;est pas possible directement. Le compiltateur a donc ajouté une méthode package statique <code>String access$000(Inner)</code> qui lit le champ (opcode <code>getfield</code>) et le renvoie à l&#8217;appelant.</p>
</div>
<div class="paragraph">
<p>Et dans le cas d&#8217;un constructeur privé ? Vat-t-on se retrouver avec une méthode statique de type <em>factory</em> qui va instancier l&#8217;object qu&#8217;on cherche à construire ? Non, ici le compilateur opte pour une autre stratégie :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Outer
{
    public Outer() {
        Inner inner = new Inner();
    }
    public class Inner {
        private Inner() {}
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>// Outer.class
**** &lt;init&gt; () -&gt; void
    0: aload $0
    1: invokespecial java/lang/Object.&lt;init&gt; {() -&gt; void}
    4: new Outer$Inner
    7: dup
    8: aload $0
    9: aconst_null
   10: invokespecial Outer$Inner.&lt;init&gt; {(Outer, Outer$1) -&gt; void}
   13: astore $1
   14: return

// Outer$Inner.class
**** &lt;init&gt; (Outer) -&gt; void
    0: aload $0
    1: aload $1
    2: putfield Outer$Inner.this$0 {Outer}
    5: aload $0
    6: invokespecial java/lang/Object.&lt;init&gt; {() -&gt; void}
    9: return

**** &lt;init&gt; (Outer, Outer$1) -&gt; void
    0: aload $0
    1: aload $1
    2: invokespecial Outer$Inner.&lt;init&gt; {(Outer) -&gt; void}
    5: return</code></pre>
</div>
</div>
<div class="paragraph">
<p>Le compilateur ajoute un second constructeur qui prend deux paramètres : le pointeur vers l&#8217;instance de la classe englobante et un paramètre de type <code>Outer$1</code>. Quelle est ce type ? Il s&#8217;agit d&#8217;une interface sans méthode créée automatiquement à la compilation. Cette interface sert simplement différencier les deux constructeurs (le second constructeur se contente d&#8217;appeler le premier). Lors de l&#8217;appel de ce constructeur ce second paramètre est mis à null (<code>null</code> est chargé sur la pile par l&#8217;opcode <code>aconst_null</code>).</p>
</div>
<div class="paragraph">
<p>Le problème principal de ces différentes <em>ruses</em> du compilateur est que cela peut rendre les stacktraces difficilement lisibles si on fait un usage immodéré des classes internes. Il vaut mieux également éviter d&#8217;appeler des méthodes privées depuis la classe englobante. L&#8217;analyseur de code <a href="http://pmd.sourceforge.net/">PMD</a> définit d&#8217;ailleurs une règle <a href="http://pmd.sourceforge.net/rules/design.html">AccessorClassGeneration</a> qui lève une alerte quand un constructeur privé est appelé depuis la classe englobante.</p>
</div>
<div class="paragraph">
<p>Et que se passe-t-il si on tente d&#8217;accéder à une méthode privée de la classe englobante depuis la classe interne ? Je vous laisse expérimenter :D.</p>
</div>
        </section>

    </article>

</main>
    <footer class="animated fadeIn" id="footer">
        <section class="colophon">
          <section class="copyright">Copyright &copy; <span itemprop="copyrightHolder">Coding Stories</span>. <span rel="license">All Rights Reserved</span>.</section>
          <section class="poweredby">Published with <a class="icon-ghost" href="http://hubpress.io">HubPress</a></section>
        </section>
        <section class="bottom">
          <section class="attribution">
            <a href="http://github.com/Reedyn/Saga">Built with <i class="fa fa-heart"></i> and Free and Open-Source Software</a>.
          </section>
        </section>
    </footer>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js?v="></script> <script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.9.0/moment-with-locales.min.js?v="></script> <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js?v="></script> 
      <script type="text/javascript">
        jQuery( document ).ready(function() {
          // change date with ago
          jQuery('ago.ago').each(function(){
            var element = jQuery(this).parent();
            element.html( moment(element.text()).fromNow());
          });
        });

        hljs.initHighlightingOnLoad();
      </script>
    <script src="//jcsirot.github.io/hubpress.io/themes/saga/assets/js/scripts.js?v=1468853091917"></script>
    
</body>
</html>
